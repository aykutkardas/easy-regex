{
  "examples.starter.title": "სავარჯიშო",
  "examples.starter.description": "ახლა კი დროა, ახლად ათვისებული საკითხების შესაჯამებლად, ცოტა წავივარჯიშოთ.",

  "examples.finish.title": "სავარჯიშო დასრულებულია!",
  "examples.finish.description": " ",

  "steps.starter.title": "შესავალი",
  "steps.starter.description": "Regex-ი არის `Regular Expression`-ის შემოკლებული ჩანაწერი. იგი გვეხმარება, შევამოწმოთ ტექსტში არსებული მსგავსებები, მოვახდინოთ ძიება ან მართვა ტექსტისა. მოდი, დავიწყოთ შემდეგით: ქვემოთ მოცემულ ველში ლათინური სიმბოლოებით შეიყვანეთ ტექსტი `OK`, რათა გადახვიდეთ პირველ ეტაპზე, სადაც მოცემული იქნება უფრო დეტალური აღწერა..",

  "steps.whatIsRegex.title": "რა არის რეგულარული გამოსახულება (`Regex`)?",
  "steps.whatIsRegex.description": "რეგულარული გამოსახულება არის სიმბოლოებისგან შემდგარი სტრიქონი, რომელიც გამოხატავს საძიებო ნიმუშს. ხშირად, შემოკლებით მოიხსენიებენ, როგორც `Regex` ან `Regexp`. განსაკუთრებით აქტიურად გამოიყენება ტექსტებში გარკვეული სიტყვების მოსაძებნად ან ჩასანაცვლებლად. გარდა ამისა, მისი მეშვეობით შეგვიძლია შევამოწმოთ, აკმაყოფილებს თუ არა ესა თუ ის ტექსტი ჩვენ მიერ განსაზღვრულ ნორმებს.\\n\\n მაგალითად, ვთქვათ, მოცემული გვაქვს ფაილების სახელთა სია და გვინდა, რომ მათ შორის მოვძებნოთ მხოლოდ `pdf` გაფართოების მქონე ფაილები. სასურველ შედეგს მივაღწევთ, თუ შევადგენთ შემდეგი სახის გამოსახულებას: `^\\w+\\.pdf$`. მომდევნო ეტაპების გავლასთან ერთად აღნიშნული გამოსახულების მუშაობის პრინციპი თანდათანობით გასაგები გახდება.",

  "steps.basicMatchers.title": "მსგავსებათა ძიება (საბაზისო)",
  "steps.basicMatchers.description": "სიტყვისა თუ ბგერის, — რომლის მოძებნაც გვსურს, — ჩაწერა უშუალოდ ხდება, მსგავსად სტანდარტული ძიების პროცესისა. მაგალითად, ტექსტში სიტყვა `curious`-ის  მოსაძებნად, შეიყვანეთ იგივე სიტყვა.",

  "steps.dotCharacter.title": "წერტილი `.`: ნებისმიერი სიმბოლო",
  "steps.dotCharacter.description": "წერტილი `.` საშუალებას გაძლევთ აირჩიოთ ნებისმიერი სიმბოლო, მათ შორის სპეციალური სიმბოლოები და ინტერვალები. გასაგრძელებლად, Regex-ის ველში შეიყვანეთ წერტილი.",

  "steps.characterSet.title": "სიმბოლოთა ნაკრები `[abc]`",
  "steps.characterSet.description": "როდესაც სიტყვაში შემავალი ერთ-ერთი სიმბოლოსთვის საჭიროა რამდენიმე ალტერნატიული შესაბამისობის განსაზღვრა, კვადრატულ ფრჩხილებში `[]` ვწერთ ყველა ალტერნატიულ სიმბოლოს. მაგალითად, რათა შეადგინოთ ისეთი გამოსახულება, რომელსაც შეეძლება [ქვემოთ მოცემულ] ტექსტში შემავალი ყოველი სიტყვის პოვნა, კვადრატულ ფრჩხილებში `[]`, გამყოფი ინტერვალების გარეშე შეიყვანეთ შემდეგი სიმბოლოები: `a`, `e`, `i`, `o`, `u`.",

  "steps.negatedCharacterSet.title": "უარყოფილ სიმბოლოთა ნაკრები `[^abc]`",
  "steps.negatedCharacterSet.description": "იმისათვის, რომ ქვემოთ მოცემულ ტექსტში იპოვოთ ყველა სიტყვა, გარდა `ber`-ისა და `bor`-ისა, კვადრატულ ფრჩხილებში `[]`, ახარისხების სიმბოლოს `^` შემდეგ შეიყვანეთ `e` და `o` სიმბოლოები გვერდი-გვერდ.",

  "steps.range.title": "ასოთა დიაპაზონი `[a-z]`",
  "steps.range.description": "იმისათვის, რომ განსაზღვრულ დიაპაზონში ვიპოვოთ ასოები, საწყისსა და საბოლოო ასოებს ვწერთ კვადრატულ ფრჩხილებში `[]` და ერთმანეთისაგან დეფისით `-` გამოვყოფთ. აღსანიშნავია, რომ მსგავსი ჩანაწერი რეგისტრის მიმართ მგრძნობიარეა. შეადგინეთ ისეთი გამოსახულება, რომელიც აარჩევს ყველა ასოს `e`-სა და `o`-ს შორის, საწყისი და საბოლოო ასოების (`e` და `o`) ჩათვლით.",

  "steps.rangeNumber.title": "ციფრთა დიაპაზონი `[0-9]`",
  "steps.rangeNumber.description": "იმისათვის, რომ განსაზღვრულ დიაპაზონში ვიპოვოთ ციფრები, საწყისსა (უმცირესი) და საბოლოო (უდიდესი) ციფრებს ვწერთ კვადრატულ ფრჩხილებში `[]` და ერთმანეთისაგან დეფისით `-` გამოვყოფთ. შეადგინეთ ისეთი გამოსახულება, რომელიც აარჩევს ყველა ციფრს `3`-ს და `6`-ს შორის, საწყისი და საბოლოო ციფრების (`3` და `6`) ჩათვლით.",

  "examples.basicMatchers.title": "სავარჯიშო: მსგავსებათა ძიება (საბაზისო)",
  "examples.basicMatchers.description": "დაწერეთ გამოსახულება, რომელიც ტექსტში აარჩევს ყველა დამთხვევას სიტყვისთვის `of`.",

  "examples.dotCharacter.title": "სავარჯიშო: ნებისმიერი სიმბოლო",
  "examples.dotCharacter.description": "დაწერეთ გამოსახულება ტექსტში ცალკეული ასოების, ციფრების, ინტერვალებისა და სპეციალური სიმბოლოების ასარჩევად. თქვენ მიერ შეყვანილი გამოსახულება შესაბამისობაში უნდა მოდიოდეს ნებისმიერ სიმბოლოსთან.",

  "examples.characterSet.title": "სავარჯიშო: სიმბოლოთა ნაკრები",
  "examples.characterSet.description": "დაწერეთ ფრაზა, რომელიც შესაბამისობაში მოვა ტექსტის თითოეულ სიტყვასთან. გაითვალისწინეთ, რომ სიტყვებს შორის განმასხვავებელი ერთადერთი სიმბოლო პირველი ასოა.",

  "examples.negatedCharacterSet.title": "სავარჯიშო: უარყოფილ სიმბოლოთა ნაკრები",
  "examples.negatedCharacterSet.description": "დაწერეთ გამოსახულება, რომელიც ტექსტში მოცემულ ყველა სიტყვასთან მოვა შესაბამისობაში, გარდა სიტყვებისა - `beor` და `beur`. განახორციელეთ ეს უარყოფილ სიმბოლოთა ნაკრების გამოყენებით.",

  "examples.range.title": "სავარჯიშო: ასოთა დიაპაზონი",
  "examples.range.description": "დაწერეთ გამოსახულება, რომელიც ტექსტში აარჩევს ასოებს `g`-იდან `k`-მდე.\\nდიაპაზონში ასევე უნდა შედიოდეს `g` და `k` ასოებიც.",

  "examples.rangeNumber.title": "სავარჯიშო: ციფრთა დიაპაზონი",
  "examples.rangeNumber.description": "დაწერეთ გამოსახულება, რათა ტექსტში აირჩიოთ ციფრები `2`-იდან `7`-მდე.\\nდიაპაზონში ასევე უნდა შედიოდეს `2` და `7`.",

  "steps.repetitions.title": "გამეორებები",
  "steps.repetitions.description": "იმის განსაზღვრისთვის, თუ რამდენჯერ მეორდება ესა თუ ის ასო (სიმბოლო) ტექსტში, რამდენიმე სპეციალური სიმბოლო გამოიყენება. ეს სპეციალური სიმბოლოებია: პლუსი `+`, ვარსკვლავი `*` და კითხვის ნიშანი `?`.",

  "steps.asterisk.title": "ვარსკვლავი `*`",
  "steps.asterisk.description": "იმის აღსანიშნავად, რომ ამა თუ იმ სიმბოლოს დამთხვევა ტექსტში შეიძლება საერთოდ არ მოხდეს, ან შეიძლება არაერთხელ მოხდეს, სიმბოლოს შემდეგ ვწერთ ვარსკვლავს `*`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` ტექსტში შეიძლება საერთოდ არ შედიოდეს ან შედიოდეს ერთხელ ან ზედიზედ მრავალჯერ.",

  "steps.plusCharacter.title": "პლუსი `+`",
  "steps.plusCharacter.description": "იმის აღსანიშნავად, რომ ესა თუ ის სიმბოლო ტექსტში შეიძლება შედიოდეს ერთხელ ან მრავალჯერ, სიმბოლოს შემდეგ ვწერთ პლუსს `+`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` ტექსტში შეიძლება შედიოდეს ერთხელ ან მრავალჯერ.",

  "steps.questionMark.title": "კითხვის ნიშანი `?`",
  "steps.questionMark.description": "იმის აღსანიშნავად, რომ ესა თუ ის სიმბოლო არასავალდებულოა, სიმბოლოს შემდეგ ვწერთ კითხვის ნიშანს `?`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `u` არასავალდებულოა.",

  "steps.quantifier.title": "ფიგურული ფრჩხილები - 1",
  "steps.quantifier.description": "იმის განსაზღვრისთვის, თუ კონკრეტულად რამდენჯერ უნდა მეორდებოდეს ესა თუ ის სიმბოლო ტექსტში, სიმბოლოს შემდეგ, ფიგურულს ფრჩხილებს შორის ვწერთ რიცხვს `{n}`, რომლითაც აღვნიშნავთ, რამდენჯერ უნდა მეორდებოდეს ეს კონკრეტული სიმბოლო ტექსტში. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მხოლოდ `2`-ჯერ.",

  "steps.quantifierMin.title": "ფიგურული ფრჩხილები - 2",
  "steps.quantifierMin.description": "იმის განსაზღვრისთვის, თუ მინიმუმ რამდენჯერ უნდა მეორდებოდეს ესა თუ ის სიმბოლო ტექსტში, სიმბოლოს შემდეგ, ფიგურულ ფრჩხილებს შორის ვწერთ მინიმალური გამეორებების რიცხვს და შემდეგ მძიმეს `{n, }`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მინიმუმ `3`-ჯერ.",

  "steps.quantifierRange.title": "ფიგურული ფრჩხილები - 3",
  "steps.quantifierRange.description": "იმისათვის, რომ განსაზღვროთ გამეორებების დასაშვები დიაპაზონი (რიცხვითი შუალედი), ფიგურულ ფრჩხილებს შორის ვწერთ გამეორებების მინიმალურ და მაქსიმალურ ოდენობას `{x,y}`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მხოლოდ `1`-იდან `3`-მდე დიაპაზონში.",

  "examples.asterisk.title": "სავარჯიშო: ვარსკვლავი `*`",
  "examples.asterisk.description": "ვარსკვლავის `*` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ყველა სიტყვასთან და დაუშვებს, რომ ასო `e` შეიძლება საერთოდ არ შედიოდეს ტექსტში, ანდა შედიოდეს ერთხელ ან ზედიზედ მრავალჯერ.",

  "examples.plusCharacter.title": "სავარჯიშო: პლუსი `+`",
  "examples.plusCharacter.description": "პლუსის `+` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ყველა იმ სიტყვასთან, რომელშიც ასო `e` შედის ერთხელ ან ზედიზედ მრავალჯერ.",

  "examples.questionMark.title": "სავარჯიშო: კითხვის ნიშანი `?`",
  "examples.questionMark.description": "შეადგინეთ რეგულარული გამოსახულება, რომელიც აღნიშნავს, რომ ასო `n` ტექსტში არასავალდებულოა. გამოიყენეთ კითხვის ნიშანი `?`. გამოსახულება შესაბამისობაში უნდა მოდიოდეს ორივე (`a` და `an`) სიტყვასთან.",

  "examples.quantifier.title": "სავარჯიშო: ფიგურული ფრჩხილები - 1",
  "examples.quantifier.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ `4` ციფრია წარმოდგენილი. გახსოვდეთ, რომ დიაპაზონი `[0-9]` შესაბამისობაში მოდის მხოლოდ ერთ ციფრთან.",

  "examples.quantifierMin.title": "სავარჯიშო: ფიგურული ფრჩხილები - 2",
  "examples.quantifierMin.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ `2` ან მეტი ციფრია წარმოდგენილი.",

  "examples.quantifierRange.title": "სავარჯიშო: ფიგურული ფრჩხილები - 3",
  "examples.quantifierRange.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ მინიმუმ `1` და მაქსიმუმ `4` ციფრია წარმოდგენილი.",

  "steps.grouping.title": "ფრჩხილები `( )`: დაჯგუფება",
  "steps.grouping.description": "Regex-ში გვაქვს შესაძლებლობა, მოვახდინოთ გამოსახულებების კლასიფიცირება (დაჯგუფება) და შემდგომში გამოვიყენოთ ეს ჯგუფები სხვადასხვა ინსტრუქციების სისრულეში მოსაყვანად. რეგულარული გამოსახულებების კლასიფიცირებისათვის ვიყენებთ ფრჩხილებს `()`. ამჯერად მოდით, დაწერეთ გამოსახულება, რომელიც ქვემოთ მოცემული ტექსტისათვის მოახდენს `haa`-ს კლასიფიცირებას.",

  "steps.groupReference.title": "ჯგუფზე მითითება",
  "steps.groupReference.description": "ქვემოთ მოცემულ მაგალითში კლასიფიცირებულია სიტყვები `ha` და `haa`. პირველ ჯგუფზე მითითება ხდება `\\1`-ის დაწერით (ამ გზით თავს ვარიდებთ გამოსახულების ერთი და იგივე ფრაგმენტის ხელახლა გადაწერას). ამ შემთხვევაში, `1` აღნიშნავს ჯგუფის რიგის ნომერს. დაწერეთ `\\2` ქვემოთ მოცემული გამოსახულების ბოლოში, რათა მოახდინოთ მითითება მეორე ჯგუფზე.",

  "steps.nonCapturingGrouping.title": "ფრჩხილები `(?: )`: დაჯგუფება რიგის ნომრის მინიჭების გარეშე",
  "steps.nonCapturingGrouping.description": "შეგიძლიათ გამოსახულებების კლასიფიცირება იმგვარადაც, რომ არ დაუშვათ მასზე მიწვდომა (მითითება) რიგის ნომრით. მაგალითად, ქვემოთ მოცემულია ორი ჯგუფი. თუმცა, პირველ ჯგუფზე მითითება, რომელსაც აღვნიშნავთ `\\1`-ით, სინამდვილეში მიუთითებს მეორე ჯგუფზე, რადგან პირველ ჯგუფს არ აქვს მინიჭებული რიგის ნომერი. დაწერეთ `\\1` ქვემოთ მოცემული გამოსახულების ბოლოში, რათა მოახდინოთ მითითება მეორე ჯგუფზე.",

  "steps.pipeCharacter.title": "ვერტიკალური ხაზი `|`",
  "steps.pipeCharacter.description": "ამ სიმბოლოს საშუალებით შეგვიძლია განვსაზღვროთ ალტერნატიული ქვეგამოსახულებები გამოსახულებაში. ამ მიზნით, ყველა შესაძლო გამოსახულება უნდა ჩაიწეროს მიყოლებით და ერთმანეთისგან გამოიყოს ვერტიკალური ხაზით `|`. ეს მეთოდი განსხვავდება სიმბოლოთა ნაკრების განსაზღვრებისაგან `[abc]`, რომელიც მხოლოდ სიმბოლოების დონეზე მუშაობს. ალტერნატიული ქვეგამოსახულებები მუშაობს გამოსახულების დონეზე. მაგალითად, ქვემოთ მოცემული გამოსახულება შესაბამისობაში მოდის სიტყვებთან `cat` და `rat`. გამოსახულების ბოლოში დაამატეთ კიდევ ერთი ვერტიკალური ხაზი `|` და დაწერეთ სიტყვა `dog`, რათა ყველა სიტყვასთან მოხდეს თანხვედრა.",

  "steps.escapeCharacter.title": "უკან გადახრილი წილადის ხაზი `\\`",
  "steps.escapeCharacter.description": "არსებობს სპეციალური სიმბოლოები, რომლებსაც რეგულარული გამოსახულებების ჩაწერისას ვიყენებთ. `{ } [ ] / \\ + * . $^ | ?` იმისათვის, რომ ეს სიმბოლოები გამოსახულებაში აღქმულ იქნეს, როგორც ჩვეულებრივი სიმბოლოები, ვიყენებთ უკან გადახრილ წილადის ხაზს `\\`. მაგალითად, იმისათვის, რომ ქვემოთ მოცემულ ტექსტში მოძიებულ იქნეს წერტილი `.` და ვარსკვლავი `*`, რეგულარულ გამოსახულებაში ორივე სიმბოლოს (`.` და `*`) წინ დაამატეთ უკან გადახრილი წილადის ხაზი `\\`.",

  "steps.caret.title": "ახარისხების ნიშანი `^`:\\nშერჩევა ხაზის დასაწყისის მიხედვით",
  "steps.caret.description": "როგორც ადრე აღვნიშნეთ, რეგულარულ გამოსახულებებში ციფრების მოძიებისთვის ვიყენებთ შემდეგნაირ ჩანაწერს: `[0-9]`. იმისათვის, რომ ქვემოთ მოცემული ტექსტის ყოველი ხაზის მხოლოდ დასაწყისში არსებული ციფრები იქნეს მოძიებული, გამოსახულებას თავსართის სახით დაურთეთ ახარისხების ნიშანი `^`.",

  "steps.dollar.title": "დოლარის ნიშანი `$`:\\nშერჩევა ხაზის დაბოლოების მიხედვით",
  "steps.dollar.description": "დაურთეთ დოლარის `$` ნიშანი სიტყვა `html`-ს ბოლოსართის სახით, რათა მოძიებულ იქნეს მხოლოდ ყოველი ხაზის ბოლოში არსებული `html`-ები.",

  "steps.wordCharacter.title": "ასო-ციფრული სიმბოლოები `\\w`: ასო, ციფრი და ქვეტირე",
  "steps.wordCharacter.description": "`\\w` ჩანაწერი გამოიყენება ტექსტში ასოების, ციფრებისა და ქვეტირეების მოსაძიებლად. ქვემოთ მოცემულ გამოსახულებაში გამოიყენეთ `\\w` ჩანაწერი, რათა მოიძიოთ ტექსტში არსებული ყველა ასო, ციფრი და ქვეტირე.",

  "steps.withoutWordCharacter.title": "გარდა ასო-ციფრული სიმბოლოებისა `\\W`",
  "steps.withoutWordCharacter.description": "ჩანაწერი `\\W` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ასოებისა, ციფრებისა და ქვეტირეებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.numberCharacter.title": "ციფრები `\\d`",
  "steps.numberCharacter.description": "ჩანაწერი `\\d` გამოიყენება მხოლოდ ციფრების მოსაძიებლად. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.withoutNumberCharacter.title": "გარდა ციფრებისა `\\D`",
  "steps.withoutNumberCharacter.description": "ჩანაწერი `\\D` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ციფრებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.spaceCharacter.title": "ინტერვალები `\\s`",
  "steps.spaceCharacter.description": "ჩანაწერი `\\s` გამოიყენება მხოლოდ ინტერვალების მოსაძიებლად. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.withoutSpaceCharacter.title": "გარდა ინტერვალებისა `\\S`",
  "steps.withoutSpaceCharacter.description": "ჩანაწერი `\\S` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ინტერვალებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.lookarounds.title": "მიმოხედვა",
  "steps.lookarounds.description": "თუ გვინდა, რომ ფრაზა, რომელსაც ვწერთ, მოსდევდეს ანდა წინ უსწრებდეს რაიმე სხვა ფრაზას, უნდა „მიმოვიხედოთ“. გადადით შემდეგ ეტაპზე, რათა შეისწავლოთ, თუ როგორ ხდება Regex-ში „მიმოხედვა“.",

  "steps.positiveLookahead.title": "დადებითი ხედვა წინ: `(?=)`",
  "steps.positiveLookahead.description": "დავუშვათ გვჭირდება, რომ ტექსტიდან ამოვიღოთ საათის აღმნიშვნელი მნიშვნელობა. ესე იგი, უნდა მივწვდეთ მხოლოდ რიცხვით მნიშვნელობებს, რომლებსაც თან სდევს `PM`-ი. ამისათვის, ქვემოთ მოცემული გამოსახულების ბოლოში დაწერეთ დადებითი ხედვის გამოსახულება `(?=)` და ფრჩხილებს შორის, ტოლობის ნიშნის `=` შემდეგ დაამატეთ `PM`-ი.",

  "steps.negativeLookahead.title": "უარყოფითი ხედვა წინ: `(?!)`",
  "steps.negativeLookahead.description": "ვთქვათ გვინდა, რომ ტექსტიდან ამოვკრიბოთ ყველა რიცხვითი მნიშვნელობა, გარდა საათის აღმნიშვნელი მნიშვნელობებისა. ამისათვის, ქვემოთ მოცემული გამოსახულების ბოლოში დაწერეთ უარყოფითი ხედვის გამოსახულება `(?!)` და ფრჩხილებს შორის, ძახილის ნიშნის `!` შემდეგ დაამატეთ `PM`-ი.",

  "steps.positiveLookbehind.title": "დადებითი ხედვა უკან: `(?<=)`",
  "steps.positiveLookbehind.description": "დავუშვათ გვინდა, რომ ტექსტიდან ამოვიღოთ ფასის მნიშვნელობა. ესე იგი, უნდა მივწვდეთ მხოლოდ რიცხვით მნიშვნელობებს, რომლებსაც წინ უსწრებს სიმბოლო `$`. ამისათვის, ქვემოთ მოცემული გამოსახულების დასაწყისში დაწერეთ დადებითი უკან ხედვის გამოსახულება `(?<=)` და ფრჩხილებს შორის, ტოლობის ნიშნის `=` შემდეგ დაამატეთ სიმბოლო `\\$`.",

  "steps.negativeLookbehind.title": "უარყოფითი ხედვა უკან: `(?&lt;!)`",
  "steps.negativeLookbehind.description": "ვთქვათ გვჭირდება, რომ ტექსტიდან ამოვკრიბოთ ყველა რიცხვითი მნიშვნელობა, გარდა ფასის მაჩვენებელი მნიშვნელობებისა. ამისათვის, ქვემოთ მოცემული გამოსახულების დასაწყისში დაწერეთ უარყოფითი უკან ხედვის გამოსახულება `(?&lt;!)` და ფრჩხილებს შორის, ძახილის ნიშნის `!` შემდეგ დაამატეთ სიმბოლო `\\$`.",

  "steps.flags.title": "ალმები",
  "steps.flags.description": "ალმები ამა თუ იმ გამოსახულებისაგან მიღებულ შედეგებს ცვლიან. სწორედ ამიტომაა, რომ ალმებს `მოდიფიკატორებადაც` მოიხსენიებენ. ალმები განსაზღვრავენ, გამოსახულება ტექსტზე იმოქმედებს, როგორც ცალკე ხაზების ერთობლიობაზე თუ ერთ მთლიან ტექსტზე; არის თუ არა გამოსახულება რეგისტრის მიმართ მგრძნობიარე; პოულობს თუ არა გამოსახულება ყველა დამთხვევას. გადადით შემდეგ ეტაპზე, რათა შეისწავლოთ Regex-ში ალმების გამოყენება.",

  "steps.flagsGlobal.title": "გლობალურობის აღმნიშვნელი ალამი",
  "steps.flagsGlobal.description": "`global` ალამი გამოსახულებას უბრძანებს, რომ ყველა შესაძლო დამთხვევა მოძებნოს ტექსტში. თუ ამ ალამს არ გამოიყენებთ, გამოსახულება იმოქმედებს მხოლოდ პირველ დამთხვევაზე ტექსტში. ახლა კი, ქვემოთ მოცემული გამოსახულებისათვის გაააქტიურეთ `global` ალამი, რათა ტექსტიდან მოახდინოთ ყველა დამთხვევის ამოკრება.",

  "steps.flagsMultiline.title": "მრავალსტრიქონიანობის აღმნიშვნელი ალამი",
  "steps.flagsMultiline.description": "Regex-ი მთელ ტექსტს ერთ სტრიქონად აღიქვამს. მაგრამ არსებობს `multiline` ალამი, რომლის გააქტიურებითაც შეგვიძლია ცალ-ცალკე ვიმოქმედოთ თითოეულ სტრიქონზე. ამ გზით, ჩვენ მიერ შედგენილი გამოსახულებები, რომელთა გამოყენებითაც სტრიქონების ბოლოში არსებულ ფრაგმენტებზე ვახდენთ მითითებას, თითოეული სტრიქონზე ცალ-ცალკე იმოქმედებს. ახლა კი, ქვემოთ მოცემული გამოსახულებისათვის გაააქტიურეთ `multiline` ალამი, რათა ტექსტიდან ამოკრიბოთ ყველა დამთხვევა.",

  "steps.flagsCaseInsensitive.title": "რეგისტრის მიმართ არამგრძნობიარეობის აღმნიშვნელი ალამი",
  "steps.flagsCaseInsensitive.description": "იმისათვის, რომ ჩვენ მიერ შედგენილი გამოსახულება რეგისტრის მიმართ მგრძნობიარე არ იყოს, უნდა გავააქტიუროთ `case-insensitive` ალამი.",

  "steps.greedyMatching.title": "„გაუმაძღარი“ ძიება",
  "steps.greedyMatching.description": "Regex-ი ნაგულისხმევად ახორციელებს „გაუმაძღარ“ ძიებას. ეს ნიშნავს, რომ დამთხვევათა ძიების პროცესი მაქსიმალურად დიდხანს გასტანს. იხილეთ ქვემოთ მოცემული მაგალითი. მოცემული გამოსახულება მიემართება `r` ასოზე დამთავრებულ ტექსტს, თანაც, მნიშვნელობა არ აქვს, რა სიმბოლოები უსწრებს წინ `r`-ს. ამასთან, ძიების პროცესი არ ჩერდება ტექსტში პირველივე ნაპოვნ დამთხვევაზე (`r`-ზე).",

  "steps.lazyMatching.title": "„ზანტი“ ძიება",
  "steps.lazyMatching.description": "„გაუმაძღარი“ ძიებისაგან განსხვავებით, „ზანტი“ ძიება ჩერდება პირველივე ნაპოვნ დამთხვევაზე. მაგალითისათვის, ქვემოთ მოცემულ გამოსახულებაში დაამატეთ კითხვის ნიშანი `?` ვარსკვლავის `*` შემდეგ, რათა მოძებნილ იქნეს პირველი დამთხვევა, რომელსაც წინ უსწრებს ნებისმიერი სიმბოლო, და ბოლოვდება ასო `r`-ზე. მაშასადამე, ძიების პროცესი შეწყდება პირველივე ნაპოვნ დამთხვევაზე (`r`-ზე).",

  "steps.completeAllSteps.title": "გილოცავთ, ყველა ეტაპი წარმატებით გაიარეთ!",
  "steps.completeAllSteps.description": "შეგიძლიათ ნებისმიერ დროს მიუბრუნდეთ განვლილ ეტაპებს და მარტივად გადახვიდეთ ერთი ეტაპიდან მეორეზე."
}
