{
  "examples.starter.title": "სავარჯიშო",
  "examples.starter.description": "Now it's time to do some practice to consolidate what we've learned.",
  "examples.starter.description": "ახლა კი დროა, ახლად ათვისებული საკითხების შესაჯამებლად, ცოტა წავივარჯიშოთ.",

  "examples.finish.title": "სავარჯიშო დასრულებულია!",
  "examples.finish.description": " ",

  "steps.starter.title": "შესავალი",
  "steps.starter.description": "Regex is short for `Regular Expression`. It helps to match, find or manage text. Start by typing `OK` in the Regex field to proceed to the first step and access the more detailed description..",
  "steps.starter.description": "Regex-ი არის `Regular Expression`-ის შემოკლებული ჩანაწერი. იგი გვეხმარება, შევამოწმოთ ტექსტში არსებული მსგავსებები, მოვახდინოთ ძიება ან მართვა ტექსტისა. მოდი, დავიწყოთ შემდეგით: ქვემოთ მოცემულ ველში ლათინური სიმბოლოებით შეიყვანეთ ტექსტი `OK`, რათა გადახვიდეთ პირველ საფეხურზე, სადაც მოცემული იქნება უფრო დეტალური აღწერა..",

  "steps.whatIsRegex.title": "What is Regular Expressions `Regex`?",
  "steps.whatIsRegex.title": "რა არის რეგულარული გამოსახულება (`Regex`)?",
  "steps.whatIsRegex.description": "Regular Expressions are a string of characters that express a search pattern. Often abbreviated as `Regex` or `Regexp`. It is especially used to find or replace words in texts. In addition, we can test whether a text complies with the rules we set.\\n\\n For example, let's say you have a list of filenames. And you only want to find files with the `pdf` extension. Following typing an expression `^\\w+\\.pdf$` will work. The meaning of the definitions in this expression will become clearer as the steps progress.",
  "steps.whatIsRegex.description": "რეგულარული გამოსახულება არის სიმბოლოებისგან შემდგარი სტრიქონი, რომელიც გამოხატავს საძიებო ნიმუშს. ხშირად, შემოკლებით მოიხსენიებენ, როგორც `Regex` ან `Regexp`. განსაკუთრებით აქტიურად გამოიყენება ტექსტებში გარკვეული სიტყვების მოსაძებნად ან ჩასანაცვლებლად. გარდა ამისა, მისი მეშვეობით შეგვიძლია შევამოწმოთ, აკმაყოფილებს თუ არა ესა თუ ის ტექსტი ჩვენ მიერ განსაზღვრულ ნორმებს.\\n\\n მაგალითად, ვთქვათ, მოცემული გვაქვს ფაილების სახელთა სია და გვინდა, რომ მათ შორის მოვძებნოთ მხოლოდ `pdf` გაფართოების მქონე ფაილები. სასურველ შედეგს მივაღწევთ, თუ შევადგენთ შემდეგი სახის გამოსახულებას: `^\\w+\\.pdf$`. მომდევნო საფეხურების გავლასთან ერთად აღნიშნული გამოსახულების მუშაობის პრინციპი თანდათანობით გასაგები გახდება.",

  "steps.basicMatchers.title": "Basic Matchers",
  "steps.basicMatchers.title": "მსგავსებათა ძიება (საბაზისო)",
  "steps.basicMatchers.description": "The character or word we want to find is written directly. It is similar to a normal search process. For example, to find the word `curious` in the text, type the same.",
  "steps.basicMatchers.description": "სიტყვისა თუ ბგერის, — რომლის მოძებნაც გვსურს, — ჩაწერა უშუალოდ ხდება, მსგავსად სტანდარტული ძიების პროცესისა. მაგალითად, ტექსტში სიტყვა `curious`-ის  მოსაძებნად, შეიყვანეთ იგივე სიტყვა.",

  "steps.dotCharacter.title": "Dot `.`: Any Character",
  "steps.dotCharacter.title": "წერტილი `.`: ნებისმიერი სიმბოლო",
  "steps.dotCharacter.description": "The period `.` allows selecting any character, including special characters and spaces. Type a period `.` in the Regex field to proceed.",
  "steps.dotCharacter.description": "წერტილი `.` საშუალებას გაძლევთ აირჩიოთ ნებისმიერი სიმბოლო, მათ შორის სპეციალური სიმბოლოები და ინტერვალები. გასაგრძელებლად, Regex-ის ველში შეიყვანეთ წერტილი.",

  "steps.characterSet.title": "Character Sets `[abc]`",
  "steps.characterSet.title": "სიმბოლოთა ნაკრები `[abc]`",
  "steps.characterSet.description": "If one of the characters in a word can be various characters, we write it in square brackets `[]` with all alternative characters. For example, to write an expression that can find all the words in the text, type the characters `a`, `e`, `i`, `o`, `u` adjacently within square brackets `[]`.",
  "steps.characterSet.description": "როდესაც სიტყვაში შემავალი ერთ-ერთი სიმბოლოსთვის საჭიროა რამდენიმე ალტერნატიული შესაბამისობის განსაზღვრა, კვადრატულ ფრჩხილებში `[]` ვწერთ ყველა ალტერნატიულ სიმბოლოს. მაგალითად, რათა შეადგინოთ ისეთი გამოსახულება, რომელსაც შეეძლება [ქვემოთ მოცემულ] ტექსტში შემავალი ყოველი სიტყვის პოვნა, კვადრატულ ფრჩხილებში `[]`, გამყოფი ინტერვალების გარეშე შეიყვანეთ შემდეგი სიმბოლოები: `a`, `e`, `i`, `o`, `u`.",

  "steps.negatedCharacterSet.title": "Negated Character Sets `[^abc]`",
  "steps.negatedCharacterSet.title": "უარყოფილ სიმბოლოთა ნაკრები `[^abc]`",
  "steps.negatedCharacterSet.description": "To find all words in the text below, except for `ber` and `bor`, type `e` and `o` side by side after the caret `^` character inside square brackets `[]`.",
  "steps.negatedCharacterSet.description": "იმისათვის, რომ ქვემოთ მოცემულ ტექსტში იპოვოთ ყველა სიტყვა, გარდა `ber`-ისა და `bor`-ისა, კვადრატულ ფრჩხილებში `[]`, ახარისხების სიმბოლოს `^` შემდეგ შეიყვანეთ `e` და `o` სიმბოლოები გვერდი-გვერდ.",

  "steps.range.title": "Letter Range`[a-z]`",
  "steps.range.title": "ასოთა დიაპაზონი `[a-z]`",
  "steps.range.description": "To find the letters in the specified range, the starting letter and the ending letter are written in square brackets `[]` with a dash between them `-`. It is case-sensitive. Type the expression that will select all lowercase letters between `e` and `o`, including themselves.",
  "steps.range.description": "იმისათვის, რომ განსაზღვრულ დიაპაზონში ვიპოვოთ ასოები, საწყისსა და საბოლოო ასოებს ვწერთ კვადრატულ ფრჩხილებში `[]` და ერთმანეთისაგან დეფისით `-` გამოვყოფთ. აღსანიშნავია, რომ მსგავსი ჩანაწერი რეგისტრის მიმართ მგრძნობიარეა. შეადგინეთ ისეთი გამოსახულება, რომელიც აარჩევს ყველა ასოს `e`-სა და `o`-ს შორის, საწყისი და საბოლოო ასოების (`e` და `o`) ჩათვლით.",

  "steps.rangeNumber.title": "Number Range`[0-9]`",
  "steps.rangeNumber.title": "ციფრთა დიაპაზონი `[0-9]`",
  "steps.rangeNumber.description": "To find the numbers in the specified range, the starting number and the ending number are written in square brackets `[]` with a dash `-` between them. Write an expression that will select all numbers between `3` and `6`, including themselves.",
  "steps.rangeNumber.description": "იმისათვის, რომ განსაზღვრულ დიაპაზონში ვიპოვოთ ციფრები, საწყისსა (უმცირესი) და საბოლოო (უდიდესი) ციფრებს ვწერთ კვადრატულ ფრჩხილებში `[]` და ერთმანეთისაგან დეფისით `-` გამოვყოფთ. შეადგინეთ ისეთი გამოსახულება, რომელიც აარჩევს ყველა ციფრს `3`-სა და `6`-ს შორის, საწყისი და საბოლოო ციფრების (`3` და `6`) ჩათვლით.",

  "examples.basicMatchers.title": "Practice: Basic Matcher",
  "examples.basicMatchers.title": "სავარჯიშო: მსგავსებათა ძიება (საბაზისო)",
  "examples.basicMatchers.description": "Write the expression that will select the words `of` in the text.",
  "examples.basicMatchers.description": "დაწერეთ გამოსახულება, რომელიც ტექსტში აარჩევს ყველა დამთხვევას სიტყვისთვის `of`.",

  "examples.dotCharacter.title": "Practice: Any Character",
  "examples.dotCharacter.title": "სავარჯიშო: ნებისმიერი სიმბოლო",
  "examples.dotCharacter.description": "Type the expression to select individual letters, numbers, spaces, and special characters in the text. The expression you type must match any character.",
  "examples.dotCharacter.description": "დაწერეთ გამოსახულება ტექსტში ცალკეული ასოების, ციფრების, ინტერვალებისა და სპეციალური სიმბოლოების ასარჩევად. თქვენ მიერ შეყვანილი გამოსახულება შესაბამისობაში უნდა მოდიოდეს ნებისმიერ სიმბოლოსთან.",

  "examples.characterSet.title": "Practice: Character Sets",
  "examples.characterSet.title": "სავარჯიშო: სიმბოლოთა ნაკრები",
  "examples.characterSet.description": "Write the phrase that matches each word in the text. The only characters that change are the initials of the words.",
  "examples.characterSet.description": "დაწერეთ ფრაზა, რომელიც შესაბამისობაში მოვა ტექსტის თითოეულ სიტყვასთან. გაითვალისწინეთ, რომ სიტყვებს შორის განმასხვავებელი ერთადერთი სიმბოლო პირველი ასოა.",

  "examples.negatedCharacterSet.title": "Practice: Negated Character Sets",
  "examples.negatedCharacterSet.title": "სავარჯიშო: უარყოფილ სიმბოლოთა ნაკრები",
  "examples.negatedCharacterSet.description": "Write down the expression that will match anything other than the words `beor` and `beur` in the text. Do this using the negated character set.",
  "examples.negatedCharacterSet.description": "დაწერეთ გამოსახოლება, რომელიც ტექსში მოცემულ ყველა სიტყვასთან მოვა შესაბამისობაში, გარდა სიტყვებისა - `beor` და `beur`. განახორციელეთ ეს უარყოფილ სიმბოლოთა ნაკრების გამოყენებით.",

  "examples.range.title": "Practice: Letter Range",
  "examples.range.title": "სავარჯიშო: ასოთა დიაპაზონი",
  "examples.range.description": "Write the expression that will select the letters from `g` to `k` in the text.\\n`g` and `k` letters should also be included in this range.",
  "examples.range.description": "დაწერეთ გამოსახულება, რომელიც ტექსტში აარჩევს ასოებს `g`-დან `k`-მდე.\\nდიაპაზონში ასევე უნდა შედიოდეს `g` და `k` ასოებიც.",

  "examples.rangeNumber.title": "Practice: Number Range",
  "examples.rangeNumber.title": "სავარჯიშო: ციფრთა დიაპაზონი",
  "examples.rangeNumber.description": "Type an expression to select numbers from `2` to `7` in the text.\\n`2` and `7` should also be included in this range.",
  "examples.rangeNumber.description": "დაწერეთ გამოსახულება, რათა ტექსტში აირჩიოთ ციფრები `2`-დან `7`-მდე.\\nდიაპაზონში ასევე უნდა შედიოდეს `2` და `7`.",

  "steps.repetitions.title": "Repetitions",
  "steps.repetitions.title": "გამეორებები",
  "steps.repetitions.description": "Some special characters are used to specify how many times a character will be repeated in the text. These special characters are the plus `+`, the asterisk `*`, and the question mark `?`.",
  "steps.repetitions.description": "იმის განსაზღვრისთვის, თუ რამდენჯერ მეორდება ესა თუ ის ასო (სიმბოლო) ტექსტში, რამდენიმე სპეციალური სიმბოლო გამოიყენება. ეს სპეციალური სიმბოლოებია: პლიუსი `+`, ვარსკვლავი `*` და კითხვის ნიშანი `?`.",

  "steps.asterisk.title": "Asterisk `*`",
  "steps.asterisk.title": "ვარსკვლავი `*`",
  "steps.asterisk.description": "We put an asterisk `*` after a character to indicate that the character may either not match at all or can match many times. For example, indicate that the letter `e` should never occur in the text, or it can occur once or more side by side.",
  "steps.asterisk.description": "იმის აღსანიშნავად, რომ ამა თუ იმ სიმბოლოს დამთხვევა ტექსტში საერთოდ არ მოხდეს, ან შეიძლება არაერთხელ მოხდეს, სიმბოლოს შემდეგ ვწერთ ვარსკვლავს `*`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` ტექსტში შეიძლება საერთოდ არ შედიოდეს ან შედიოდეს ერთხელ ან ზედიზედ მრავალჯერ.",

  "steps.plusCharacter.title": "Plus Sign `+`",
  "steps.plusCharacter.title": "პლიუსი `+`",
  "steps.plusCharacter.description": "To indicate that a character can occur one or more times, we put a plus sign `+` after a character. For example, indicate that the letter `e` can occur one or more times in the text.",
  "steps.plusCharacter.description": "იმის აღსანიშნავად, რომ ესა თუ ის სიმბოლო ტექსტში შეიძლება შედიოდეს ერთხელ ან მრავალჯერ, სიმბოლოს შემდეგ ვწერთ პლიუსს `+`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` ტექსტში შეიძლება შედიოდეს ერთხელ ან მრავალჯერ.",

  "steps.questionMark.title": "Question Mark `?`",
  "steps.questionMark.title": "კითხვის ნიშანი `?`",
  "steps.questionMark.description": "To indicate that a character is optional, we put a `?` question mark after a character. For example, indicate that the following letter `u` is optional.",
  "steps.questionMark.description": "იმის აღსანიშნავად, რომ ესა თუ ის სიმბოლო არასავალდებულოა, სიმბოლოს შემდეგ ვწერთ კითხვის ნიშანს `?`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `u` არასავალდებულია.",

  "steps.quantifier.title": "Curly Braces - 1",
  "steps.quantifier.title": "ფიგურული ფრჩხილები - 1",
  "steps.quantifier.description": "To express a certain number of occurrences of a character,  at the end we write curly braces `{n}` along with how many times we want it to occur. For example, indicate that the following letter `e` can occur only `2` times.",
  "steps.quantifier.description": "იმის განსაზღვრისთვის, თუ კონკრეტულად რამდენჯერ უნდა მეორდებოდეს ესა თუ ის სიმბოლო ტექსტში, სიმბოლოს შემდეგ, ფიგურულს ფრჩხილებს შორის ვწერთ რიცხვს `{n}`, რომლითაც აღვნიშნავთ, რამდენჯერ უნდა მეორდებოდეს ეს კონკრეტული სიმბოლო ტექსტში. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მხოლოდ `2`-ჯერ.",

  "steps.quantifierMin.title": "Curly Braces - 2",
  "steps.quantifierMin.title": "ფიგურული ფრჩხილები - 2",
  "steps.quantifierMin.description": "To express at least a certain number of occurrences of a character, immediately after the character we write at least how many times we want it to occur followed by a comma `,` and wrapped inside curly braces `{n, }`. For example, indicate that the following letter `e` can occur at least `3` times.",
  "steps.quantifierMin.description": "იმის განსაზღვრისთვის, თუ მინიმუმ რამდენჯერ უნდა მეორდებოდეს ესა თუ ის სიმბოლო ტექსტში, სიმბოლოს შემდეგ, ფიგურულ ფრჩხილებს შორის ვწერთ მინიმალური გამეორებების რიცხვს და შემდეგ მძიმეს `{n, }`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მინიმუმ `3`-ჯერ.",

  "steps.quantifierRange.title": "Curly Braces - 3",
  "steps.quantifierRange.title": "ფიგურული ფრჩხილები - 3",
  "steps.quantifierRange.description": "To express the occurrence of a character in a certain number range, we write curly braces `{x,y}` with the interval we want to go to the end. For example, indicate that the following letter `e` can only occur between `1` and `3`.",
  "steps.quantifierRange.description": "იმისათვის, რომ განსაზღვროთ გამეორებების დასაშვები დიაპაზონი (რიცხვითი შუალედი), ფიგურულ ფრჩხილებს შორის ვწერთ გამეორებების მინიმალურ და მაქსიმალურ ოდენობას `{x,y}`. მაგალითად, ქვემოთ მოცემული ტექსტისათვის შეადგინეთ რეგულარული გამოსახულება, რომლითაც აღნიშნავთ, რომ ასო `e` უნდა მეორდებოდეს მხოლოდ `1`-დან `3`-მდე დიაპაზონში.",

  "examples.asterisk.title": "Practice: Asterisk `*`",
  "examples.asterisk.title": "სავარჯიშო: ვარსკვლავი `*`",
  "examples.asterisk.description": "Use the asterisk `*` to write the expression that will select each word, suitable for the absence of the letter `e` in the text and the presence of one or more.",
  "examples.asterisk.description": "ვარსკვლავის `*` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ყველა სიტყვასთან და დაუშვებს, რომ ასო `e` შეიძლება საერთოდ არ შედიოდეს ტექსტში, ანდა შედიოდეს ერთხელ ან ზედიზედ მრავალჯერ.",

  "examples.plusCharacter.title": "Practice: Plus Sign `+`",
  "examples.plusCharacter.title": "სავარჯიშო: პლიუსი `+`",
  "examples.plusCharacter.description": "Write the expression using the plus sign `+` to select words in which the letter `e` occurs one or more times in the text.",
  "examples.plusCharacter.description": "პლიუსის `+` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ყველა იმ სიტყვასთან, რომელშიც ასო `e` შედის ერთხელ ან ზედიზედ მრავალჯერ.",

  "examples.questionMark.title": "Practice: Question Mark `?`",
  "examples.questionMark.title": "სავარჯიშო: კითხვის ნიშანი `?`",
  "examples.questionMark.description": "Write the expression indicating that the letter `n` is optional in the text, using the question mark `?`. Thus, both the words `a` and `an` can be selected.",
  "examples.questionMark.description": "შეადგინეთ რეგულარული გამოსახულება, რომელიც აღნიშნავს, რომ ასო `n` ტექსტში არასავალდებულოა. გამოიყენეთ კითხვის ნიშანი `?`. გამოსახულება შესაბასობაში უნდა მოდიოდეს ორივე (`a` და `an`) სიტყვასთან.",

  "examples.quantifier.title": "Practice: Curly Braces - 1",
  "examples.quantifier.title": "სავარჯიშო: ფიგურული ფრჩხილები - 1",
  "examples.quantifier.description": "Write the expression using curly braces `{}` that will find texts containing `4` numbers side by side. Remember that the range `[0-9]` will match a single digit.",
  "examples.quantifier.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ `4` ციფრია წარმოდგენილი. გახსოვდეთ, რომ დიაპაზონი `[0-9]` შესაბამისობაში მოდის მხოლოდ ერთ ციფრთან.",

  "examples.quantifierMin.title": "Practice: Curly Braces - 2",
  "examples.quantifierMin.title": "სავარჯიშო: ფიგურული ფრჩხილები - 2",
  "examples.quantifierMin.description": "Write the expression using curly braces `{}` that will find texts containing at least `2` numbers side by side.",
  "examples.quantifierMin.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ `2` ან მეტი ციფრია წარმოდგენილი.",

  "examples.quantifierRange.title": "Practice: Curly Braces - 3",
  "examples.quantifierRange.title": "სავარჯიშო: ფიგურული ფრჩხილები - 3",
  "examples.quantifierRange.description": "Write the expression using curly braces `{}` that will find texts containing at least `1` and at most `4` numbers side by side.",
  "examples.quantifierRange.description": "ფიგურული ფრჩხილების `{}` გამოყენებით შეადგინეთ რეგულარული გამოსახულება, რომელიც შესაბამისობაში მოვა ტექსტის იმ ფრაგმენტთან ან ფრაგმენტებთან, სადაც ზედიზედ მინიმუმ `1` და მაქსიმუმ `4` ციფრია წარმოდგენილი.",

  "steps.grouping.title": "Parentheses `( )`: Grouping",
  "steps.grouping.title": "ფრჩხილები `( )`: დაჯგუფება",
  "steps.grouping.description": "We can group an expression and use these groups to reference or enforce some rules. To group an expression, we enclose `()` in parentheses. For now just group `haa` below.",
  "steps.grouping.description": "Regex-ში გვაქვს შესაძლობლობა, მოვახდინოთ გამოსახულებების კლასიფიცირება (დაჯგუფება) და შემდგომში გამოვიყენოთ ეს ჯგუფები სხვადასსხვა ინსტრუქციების სისრულეში მოსაყვანად. რეგულარული გამოსახულებების კლასიფიცირებისათვის ვიყენებთ ფრჩხილებს `()`. ამჯერად მოდით, დაწერეთ გამოსახულება, რომელიც ქვემოთ მოცემული ტექსტისათვის მოახდენს `haa`-ს კლასიფიცირებას.",

  "steps.groupReference.title": "Referencing a Group",
  "steps.groupReference.title": "ჯგუფზე მითითება (Referencing)",
  "steps.groupReference.description": "The words `ha` and `haa` are grouped below. The first group is used by writing `\\1` to avoid rewriting. Here `1` denotes the order of grouping. Type `\\2` at the end of the expression to refer to the second group.",
  "steps.groupReference.description": "ქვემოთ მოცემულ მაგალითში კლასიფიცირებულია სიტყვები `ha` და `haa`. პირველ ჯგუფზე მითითება ხდება `\\1`-ის დაწერით (ამ გზით თავს ვარიდებთ გამოსახულების ერთი და იგივე ფრაგმენტის ხელახლა გადაწერას). ამ შემთხვევაში, `1` აღნიშნავს ჯგუფის რიგის ნომერს. დაწერეთ `\\2` ქვემოთ მოცემული გამოსახულების ბოლოში, რათა მოახდინოთ მითითება მეორე ჯგუფზე.",

  "steps.nonCapturingGrouping.title": "Parentheses `(?: )`: Non-capturing Grouping",
  "steps.nonCapturingGrouping.title": "ფრჩხილები `(?: )`: დაჯგუფება რიგის ნომრის მინიჭების გარეშე",
  "steps.nonCapturingGrouping.description": "You can group an expression and ensure that it is not captured by references. For example, below are two groups. However, the first group reference we denote with `\\1` actually indicates the second group, as the first is a non-capturing group.",
  "steps.nonCapturingGrouping.description": "შეგიძლიათ გამოსახულებების კლასიფიცირება იმგვარადაც, რომ არ დაუშვათ მასზე მიწვდომა (მითითება) რიგის ნომრით. მაგალითად, ქვემოთ მოცემულია ორი ჯგუფი. თუმცა, პირველ ჯგუფზე მითითება, რომელსაც აღვნიშნავთ `\\1`-ით, სინამდვილეში მიუთითებს მეორე ჯგუფზე, რადგან პირველ ჯგუფს არ აქვს მინიჭებული რიგის ნომერი. დაწერეთ `\\1` ქვემოთ მოცემული გამოსახულების ბოლოში, რათა მოახდინოთ მითითება მეორე ჯგუფზე.",

  "steps.pipeCharacter.title": "Pipe Character `|`",
  "steps.pipeCharacter.title": "ვერტიკალური ხაზი `|`",
  "steps.pipeCharacter.description": "It allows to specify that an expression can be in different expressions. Thus, all possible statements are written separated by the pipe sign `|`. This differs from charset `[abc]`, charsets operate at the character level. Alternatives are at the expression level. For example, the following expression would select both `cat` and `rat`. Add another pipe sign `|` to the end of the expression and type `dog` so that all words are selected.",
  "steps.pipeCharacter.description": "ამ სიმბოლოს საშუალებით შეგვიძლია განვსაზღვროთ ალტერნატიული ქვეგამოსახულებები გამოსახულებაში. ამ მიზნით, ყველა შესაძლო გამოსახულება უნდა ჩაიწეროს მიყოლებით და ერთმანეთისგან გამოიყოს ვერტიკალური ხაზით `|`. ეს მეთოდი განსხვავდება სიმბოლოთა ნაკრების განსაზღვრებისაგან `[abc]`, რომელიც მხოლოდ სიმბოლოების დონეზე მუშაობს. ალტერნატიული ქვეგამოსახულებები მუშაობს გამოსახულების დონეზე. მაგალითად, ქვემოთ მოცემული გამოსახულება შესაბამისობაში მოდის სიტყვებთან `cat` და `rat`. გამოსახულების ბოლოში დაამატეთ კიდევ ერთი ვერტიკალური ხაზი `|` და დაწერეთ სიტყვა `dog`, რათა ყველა სიტყვასთან მოხდეს თანხვედრა.",

  "steps.escapeCharacter.title": "Escape Character `\\`",
  "steps.escapeCharacter.title": "უკან გადახრილი წილადის ხაზი `\\`",
  "steps.escapeCharacter.description": "There are special characters that we use when writing regex. `{ } [ ] / \\ + * . $^ | ?` Before we can select these characters themselves, we need to use an escape character `\\`. For example, to select the dot `.` and asterisk `*` characters in the text, let's add an escape character `\\` before it.",
  "steps.escapeCharacter.description": "არსებობს სპეციალური სიმბოლები, რომლებსაც რეგულარული გამოსახულებების ჩაწერისას ვიყენებთ. `{ } [ ] / \\ + * . $^ | ?` იმისათვის, რომ ეს სიმბოლოები გამოსახულებაში აღქმულ იქნეს, როგორც ჩვეულებრივი სიმბოლოები, ვიყენებთ უკან გადახრილ წილადის ხაზს `\\`. მაგალითად, იმისათვის, რომ ქვემოთ მოცემულ ტექსტში მოძიებულ იქნეს წერტილი `.` და ვარსკვლავი `*`, რეგულარულ გამოსახულებაში ორივე სიმბოლოს (`.` და `*`) წინ დაამატეთ უკან გადახრილი წილადის ხაზი `\\`.",

  "steps.caret.title": "Caret Sign `^`:\\nSelecting by Line Start",
  "steps.caret.title": "ახარისხების ნიშანი `^`:\\nშერჩევა ხაზის დასაწყისის მიხედვით",
  "steps.caret.description": "We were using `[0-9]` to find numbers. To find only numbers at the beginning of a line, prefix this expression with the `^` sign.",
  "steps.caret.description": "როგორც ადრე აღვნიშნეთ, რეგულარულ გამოსახულებებში ციფრების მოძიებისთვის ვიყენებთ შემდეგნაირ ჩანაწერს: `[0-9]`. იმისათვის, რომ ქვემოთ მოცემული ტექსტის ყოველი ხაზის მხოლოდ დასაწყისში არსებული ციფრები იქნეს მოძიებული, გამოსახულებას თავსართის სახით დაურთეთ ახარისხების ნიშანი `^`.",

  "steps.dollar.title": "Dollar Sign `$`:\\nSelecting by End of Line",
  "steps.dollar.title": "დოლარის ნიშანი `$`:\\nშერჩევა ხაზის დაბოლოების მიხედვით",
  "steps.dollar.description": "Let's use the `$` sign after the `html` value to find the `html` texts only at the end of the line.",
  "steps.dollar.description": "დაურთეთ დოლარის `$` ნიშანი სიტყვა `html`-ს ბოლოსართის სახით, რათა მოძიებულ იქნეს მხოლოდ ყოველი ხაზის ბოლოში არსებული `html`-ები.",

  "steps.wordCharacter.title": "Word Character `\\w`: Letter, Number and Underscore",
  "steps.wordCharacter.title": "ასო-ციფრული სიმბოლოები `\\w`: ასო, ციფრი და ქვეტირე",
  "steps.wordCharacter.description": "The expression `\\w` is used to find letters, numbers and underscore characters. Let's use the expression `\\w` to find word characters in the text.",
  "steps.wordCharacter.description": "`\\w` ჩანაწერი გამოიყენება ტექსტში ასოების, ციფრებისა და ქვეტირეების მოსაძიებლად. ქვემოთ მოცემულ გამოსახულებაში გამოიყენეთ `\\w` ჩანაწერი, რათა მოიძიოთ ტექსტში არსებული ყველა ასო, ციფრი და ქვეტირე.",

  "steps.withoutWordCharacter.title": "Except Word Character `\\W`",
  "steps.withoutWordCharacter.title": "გარდა ასო-ციფრული სიმბოლოებისა `\\W`",
  "steps.withoutWordCharacter.description": "The expression `\\W` is used to find characters other than letters, numbers, and underscores.",
  "steps.withoutWordCharacter.description": "ჩანაწერი `\\W` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ასოებისა, ციფრებისა და ქვეტირეებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.numberCharacter.title": "Number Character `\\d`",
  "steps.numberCharacter.title": "ციფრები `\\d`",
  "steps.numberCharacter.description": "`\\d` is used to find only number characters.",
  "steps.numberCharacter.description": "ჩანაწერი `\\d` გამოიყენება მხოლოდ ციფრების მოსაძიებლად. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.withoutNumberCharacter.title": "Except Number Character `\\D`",
  "steps.withoutNumberCharacter.title": "გარდა ციფრებისა `\\D`",
  "steps.withoutNumberCharacter.description": "`\\D` is used to find non-numeric characters.",
  "steps.withoutNumberCharacter.description": "ჩანაწერი `\\D` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ციფრებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.spaceCharacter.title": "Space Character `\\s`",
  "steps.spaceCharacter.title": "ინტერვალები `\\s`",
  "steps.spaceCharacter.description": "`\\s` is used to find only space characters.",
  "steps.spaceCharacter.description": "ჩანაწერი `\\s` გამოიყენება მხოლოდ ინტერვალების მოსაძიებლად. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.withoutSpaceCharacter.title": "Except Space Character `\\S`",
  "steps.withoutSpaceCharacter.title": "გარდა ინტერვალებისა `\\S`",
  "steps.withoutSpaceCharacter.description": "`\\S` is used to find non-space characters.",
  "steps.withoutSpaceCharacter.description": "ჩანაწერი `\\S` გამოიყენება ტექსტში შემავალი ყველა სიმბოლოს მოსაძიებლად, გარდა ინტერვალებისა. გამოიყენეთ აღნიშნული ჩანაწერი ქვემოთ მოცემულ გამოსახულებაში.",

  "steps.lookarounds.title": "Lookarounds",
  "steps.lookarounds.title": "მიმოხედვა",
  "steps.lookarounds.description": "If we want the phrase we're writing to come before or after another phrase, we need to \"lookaround\". Take the next step to learn how to \"lookaround\".",
  "steps.lookarounds.description": "თუ გვინდა, რომ ფრაზა, რომელსაც ვწერთ, მოსდევდეს ანდა წინ უსწრებდეს რაიმე სხვა ფრაზას, უნდა „მიმოვიხედოთ“. გადადით შემდეგ საფეხურზე, რათა შეისწავლოთ, თუ როგორ ხდება Regex-ში „მიმოხედვა“.",

  "steps.positiveLookahead.title": "Positive Lookahead: `(?=)`",
  "steps.positiveLookahead.title": "დადებითი ხედვა წინ: `(?=)`",
  "steps.positiveLookahead.description": "For example, we want to select the hour value in the text. Therefore, to select only the numerical values that have `PM` after them, we need to write the positive look-ahead expression `(?=)` after our expression. Include `PM` after the `=` sign inside the parentheses.",
  "steps.positiveLookahead.description": "დავუშვათ გვჭირდება, რომ ტექსტიდან ამოვიღოთ საათის აღმნიშვნელი მნიშვნელობა. ესე იგი, უნდა მივწვდეთ მხოლოდ რიცხვით მნიშვნელობებს, რომლებსაც თან სდევს `PM`-ი. ამისათვის, ქვემოთ მოცემული გამოსახულების ბოლოში დაწერეთ დადებითი ხედვის გამოსახულება `(?=)` და ფრჩხილებს შორის, ტოლობის ნიშნის `=` შემდეგ დაამატეთ `PM`-ი.",

  "steps.negativeLookahead.title": "Negative Lookahead: `(?!)`",
  "steps.negativeLookahead.title": "უარყოფითი ხედვა წინ: `(?!)`",
  "steps.negativeLookahead.description": "For example, we want to select numbers other than the hour value in the text. Therefore, we need to write the negative look-ahead `(?!)` expression after our expression to select only the numerical values that do not have `PM` after them. Include `PM` after the `!` sign inside the parentheses.",
  "steps.negativeLookahead.description": "ვთქვათ გვინდა, რომ ტექსტიდან ამოვკრიბოთ ყველა რიცხვითი მნიშვნელობა, გარდა საათის აღმნიშვნელი მნიშვნელობებისა. ამისათვის, ქვემოთ მოცემული გამოსახულების ბოლოში დაწერეთ უარყოფითი ხედვის გამოსახულება `(?!)` და ფრჩხილებს შორის, ძახილის ნიშნის `!` შემდეგ დაამატეთ `PM`-ი.",

  "steps.positiveLookbehind.title": "Positive Lookbehind: `(?<=)`",
  "steps.positiveLookbehind.title": "დადებითი ხედვა უკან: `(?<=)`",
  "steps.positiveLookbehind.description": "For example, we want to select the price value in the text. Therefore, to select only the number values that are preceded by `$`, we need to write the positive lookbehind expression `(?<=)` before our expression. Add `\\$` after the `=` sign inside the parenthesis.",
  "steps.positiveLookbehind.description": "დავუშვათ გვინდა, რომ ტექსტიდან ამოვიღოთ ფასის მნიშვნელობა. ესე იგი, უნდა მივწვდეთ მხოლოდ რიცხვით მნიშვნელობებს, რომლებსაც წინ უსწრებს სიმბოლო `$`. ამისათვის, ქვემოთ მოცემული გამოსახულების დასაწყისში დაწერეთ დადებითი უკან ხედვის გამოსახულება `(?<=)` და ფრჩხილებს შორის, ტოლობის ნიშნის `=` შემდეგ დაამატეთ სიმბოლო `\\$`.",

  "steps.negativeLookbehind.title": "Negative Lookbehind: `(?&lt;!)`",
  "steps.negativeLookbehind.title": "უარყოფითი ხედვა უკან: `(?&lt;!)`",
  "steps.negativeLookbehind.description": "For example, we want to select numbers in the text other than the price value. Therefore, to select only numeric values that are not preceded by `$`, we need to write the negative lookbehind `(?&lt;!)` before our expression. Add `\\$` after the `!` inside the parenthesis.",
  "steps.negativeLookbehind.description": "ვთქვათ გვჭირდება, რომ ტექსტიდან ამოვკრიბოთ ყველა რიცხვითი მნიშვნელობა, გარდა ფასის მაჩვენებელი მნიშვნელობებისა. ამისათვის, ქვემოთ მოცემული გამოსახულების დასაწყისში დაწერეთ უარყოფითი უკან ხედვის გამოსახულება `(?&lt;!)` და ფრჩხილებს შორის, ძახილის ნიშნის `!` შემდეგ დაამატეთ სიმბოლო `\\$`.",

  "steps.flags.title": "Flags",
  "steps.flags.title": "ალმები",
  "steps.flags.description": "Flags change the output of the expression. That's why flags are also called `modifiers`. Flags determine whether the typed expression treats text as separate lines, is case sensitive, or finds all matches. Continue to the next step to learn the flags.",
  "steps.flags.description": "ალმები ამა თუ იმ გამოსახულებისაგან მიღებულ შედეგებს ცვლიან. სწორედ ამიტომაა, რომ ალმებს `მოდიფიკატორებადაც` მოიხსენიებენ. ალმები განსაზღვრავენ, გამოსახულება ტექსტზე იმოქმედებს, როგორც ცალკე ხაზების ერთობლიობაზე თუ ერთ მთლიან ტექსტზე; არის თუ არა გამოსახულება რეგისტრის მიმართ მგრძნობიარე; პოულობს თუ არა გამოსახულება ყველა დამთხვევას. გადადით შემდეგ საფეხურზე, რათა შეისწავლოთ Regex-ში ალმების გამოყენება.",

  "steps.flagsGlobal.title": "Global Flag",
  "steps.flagsGlobal.description": "The `global` flag causes the expression to select all matches. If not used it will only select the first match. Now enable the `global` flag to be able to select all matches.",

  "steps.flagsMultiline.title": "Multiline Flag",
  "steps.flagsMultiline.description": "Regex sees all text as one line. But we use the `multiline` flag to handle each line separately. In this way, the expressions we write to identify patterns at the end of lines work separately for each line. Now enable the `multiline` flag to find all matches.",

  "steps.flagsCaseInsensitive.title": "Case-insensitive Flag",
  "steps.flagsCaseInsensitive.description": "In order to remove the case-sensitivity of the expression we have written, we must activate the `case-insensitive` flag.",

  "steps.greedyMatching.title": "Greedy Matching",
  "steps.greedyMatching.description": "Regex does a greedy match by default. This means that the matchmaking will be as long as possible. Check out the example below. It refers to any match that ends in `r` and can be any character preceded by it. But it does not stop at the first letter `r`.",

  "steps.lazyMatching.title": "Lazy Matching",
  "steps.lazyMatching.description": "Lazy matchmaking, unlike greedy matching, stops at the first matching. For example, in the example below, add a `?` after `*` to find the first match that ends with the letter `r` and is preceded by any character. It means that this match will stop at the first letter `r`.",

  "steps.completeAllSteps.title": "Congratulations, you have completed all the steps!",
  "steps.completeAllSteps.description": "You can return to the previous steps whenever you want, and you can easily navigate through all the steps you have passed."
}
